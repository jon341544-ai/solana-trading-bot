#!/usr/bin/env python3 """ Futures trading bot for SOL/USDT on CoinCatch. Key improvements over the original version: * Fixed typo “timInForce” → “timeInForce”. * Updated POST handling – now reads JSON body instead of query‑string args. * Added robust error handling & logging (standard library `logging`). * Introduced a lightweight `threading.Lock` to protect shared `trading_state`. * Removed unused `numpy` import. * Indicator helpers now return ``None`` on failure (instead of silent constants). * Slightly refined trend‑strength scoring logic. * Minor readability / safety tweaks. """ import os import time import hmac import hashlib import base64 import json import logging import threading from datetime import datetime from zoneinfo import ZoneInfo import pandas as pd import requests from flask import Flask, jsonify, request, render_template # --------------------------------------------------------------------------- # # Logging configuration # ------------------------------------------------------------------------ # logging.basicConfig( level=logging.INFO, format="%(asctime)s %(levelname)s %(threadName)s %(message)s", ) log = logging.getLogger(__name__) # --------------------------------------------------------------------------- # # Flask app # --------------------------------------------------------------------------- # app = Flask(__name__) # --------------------------------------------------------------------------- # # Configuration # --------------------------------------------------------------------------- # class Config: """Load environment variables and hold static trading parameters.""" def __init__(self): self.api_key = os.getenv("COINCATCH_API_KEY", "") self.api_secret = os.getenv("COINCATCH_API_SECRET", "") self.passphrase = os.getenv("COINCATCH_PASSPHRASE", "") self.base_url = "https://api.coincatch.com" self.is_configured = bool(self.api_key and self.api_secret and self.passphrase) # Timezone used for timestamps shown to the user self.timezone = ZoneInfo("America/New_York") # -------------------- USER‑CONFIGURABLE SETTINGS -------------------- self.leverage_multiplier = 5 # 1‑20× self.base_position_size = 0.1 # SOL (before leverage) self.check_interval = 300 # seconds (5 min) # Indicator parameters self.rsi_period = 7 self.macd_fast = 6 self.macd_slow = 13 self.macd_signal = 5 # Risk management self.max_daily_loss = 0.10 # 10 % of daily starting balance self.stop_loss_pct = 0.05 # 5 % self.take_profit_pct = 0.10 # 10 % # Trading specifics self.symbol = "SOLUSDT_UMCBL" self.margin_mode = "crossed" # or "isolated" self.position_side = "LONG" # auto‑decided later config = Config() def get_ny_time() -> datetime: """Current time in the configured New‑York timezone.""" return datetime.now(config.timezone) # --------------------------------------------------------------------------- # # Shared mutable state (protected by a lock) # --------------------------------------------------------------------------- # class TradingState: """Runtime state that is accessed from both the Flask thread and the bot thread.""" def __init__(self): self.lock = threading.Lock() # protects all mutable attributes below self.is_running = False self.current_position = None # "long", "short", or None self.position_size = 0.0 self.entry_price = 0.0 self.unrealized_pnl = 0.0 self.realized_pnl = 0.0 self.last_trade_time = None self.last_signals = {} self.trade_history = [] # Daily performance tracking self.daily_starting_balance = 0.0 self.daily_start_time = get_ny_time() self.total_trades = 0 self.winning_trades = 0 trading_state = TradingState() # --------------------------------------------------------------------------- # # Helper: authenticated HTTP request to CoinCatch # --------------------------------------------------------------------------- # def make_api_request(method: str, endpoint: str, data: dict | None = None) -> dict: """Perform a signed request against the CoinCatch REST API.""" if not config.is_configured: return {"error": "API credentials not configured"} try: timestamp = str(int(time.time() * 1000)) body_str = json.dumps(data) if data else "" message = f"{timestamp}{method.upper()}{endpoint}{body_str}" signature = base64.b64encode( hmac.new( config.api_secret.encode("utf-8"), message.encode("utf-8"), hashlib.sha256, ) ).decode() headers = { "ACCESS-KEY": config.api_key, "ACCESS-SIGN": signature, "ACCESS-TIMESTAMP": timestamp, "ACCESS-PASSPHRASE": config.passphrase, "Content-Type": "application/json", } url = config.base_url + endpoint timeout = 5 if method.upper() == "GET": resp = requests.get(url, headers=headers, timeout=timeout) else: resp = requests.post(url, headers=headers, json=data, timeout=timeout) # Try to decode JSON regardless of status code try: payload = resp.json() except ValueError: payload = {"error": f"Non‑JSON response (HTTP {resp.status_code})"} if resp.status_code == 200: return payload else: # Normalise error shape return { "error": f"HTTP {resp.status_code}", "message": payload.get("msg") or payload.get("error") or str(payload), } except Exception as exc: # pragma: no cover – defensive log.exception("Request to %s failed", endpoint) return {"error": f"Request failed: {exc}"} # --------------------------------------------------------------------------- # # Market data helpers # --------------------------------------------------------------------------- # def get_current_price() -> float | None: """Return the latest SOL price from the futures ticker.""" result = make_api_request( "GET", f"/api/mix/v1/market/ticker?symbol={config.symbol}" ) if "error" in result: log.error("Failed to fetch price: %s", result.get("message")) return None # The official field is `lastPrice`; fall back to `last` or `lastPr` data = result.get("data", {}) if isinstance(data, dict): price = ( data.get("lastPrice") or data.get("last") or data.get("lastPr") or data.get("price") ) try: return float(price) except (TypeError, ValueError): return None return None def get_klines(interval: str = "5m", limit: int = 50) -> pd.DataFrame | None: """Fetch recent candlesticks for the configured symbol.""" interval_map = { "1m": "60", "5m": "300", "15m": "900", "30m": "1800", "1H": "3600", "4H": "14400", "1D": "86400", } granularity = interval_map.get(interval, "300") endpoint = ( f"/api/mix/v1/market/candles?" f"symbol={config.symbol}&granularity={granularity}&limit={limit}" ) result = make_api_request("GET", endpoint) if "error" in result: log.error("Failed to fetch klines: %s", result.get("message")) return None data = result.get("data") if not data: return None df = pd.DataFrame(data) if df.empty: return None # Standardise column names (CoinCatch returns 6 columns at minimum) expected = ["timestamp", "open", "high", "low", "close", "volume"] if len(df.columns) >= 6: df.columns = expected + list(df.columns[6:]) # Cast numeric columns safely for col in ["open", "high", "low", "close", "volume"]: df[col] = pd.to_numeric(df[col], errors="coerce") return df # --------------------------------------------------------------------------- # # Indicator calculations # --------------------------------------------------------------------- # def calculate_rsi(df: pd.DataFrame, period: int = 14) -> float | None: """Relative Strength Index – returns ``None`` on failure.""" try: delta = df["close"].diff() gain = delta.clip(lower=0).rolling(window=period).mean() loss = (-delta.clip(upper=0)).rolling(window=period).mean() rs = gain / loss rsi = 100 - (100 / (1 + rs)) latest = rsi.iloc[-1] return float(latest) if not pd.isna(latest) else None except Exception: log.exception("RSI calculation failed") return None def calculate_macd( df: pd.DataFrame, fast: int = 12, slow: int = 26, signal: int = 9 ) -> int | None: """ MACD line vs. signal line. Returns: 1 → bullish (MACD > signal) -1 → bearish (MACD < signal) 0 → neutral / error """ try: close = df["close"] ema_fast = close.ewm(span=fast, adjust=False).mean() ema_slow = close.ewm(span=slow, adjust=False).mean() macd_line = ema_fast - ema_slow signal_line = macd_line.ewm(span=signal, adjust=False).mean() if macd_line.iloc[-1] > signal_line.iloc[-1]: return 1 elif macd_line.iloc[-1] < signal_line.iloc[-1]: return -1 else: return 0 except Exception: log.exception("MACD calculation failed") return None def calculate_trend_strength(df: pd.DataFrame) -> float | None: """ Simple multi‑timeframe trend strength. Positive → up‑trend, Negative → down‑trend. """ try: # 5‑period and 10‑period price changes (relative) price_now = df["close"].iloc[-1] price_5 = df["close"].iloc[-5] price_10 = df["close"].iloc[-10] change_5 = (price_now - price_5) / price_5 change_10 = (price_now - price_10) / price_10 # Average absolute magnitude, then re‑apply direction of the shorter window strength = (abs(change_5) + abs(change_10)) / 2 direction = 1 if change_5 > 0 else -1 return strength * direction except Exception: log.exception("Trend strength calculation failed") return None # --------------------------------------------------------------------------- # # Signal generation # --------------------------------------------------------------------------- # def get_trading_signals() -> dict | None: """Collect market data, compute indicators, and decide on an action.""" df = get_klines(interval="5m", limit=50) price = get_current_price() if df is None or price is None: return None # Compute indicators (allow ``None`` results) rsi = calculate_rsi(df, config.rsi_period) macd_sig = calculate_macd(df, config.macd_fast, config.macd_slow, config.macd_signal) trend = calculate_trend_strength(df) # Guard against missing indicator data – treat as neutral rsi = rsi if rsi is not None else 50.0 macd_sig = macd_sig if macd_sig is not None else 0 trend = trend if trend is not None else 0.0 signals = { "rsi": rsi, "macd": macd_sig, "trend_strength": abs(trend), "trend_direction": 1 if trend > 0 else -1, "price": price, "timestamp": get_ny_time().isoformat(), } # ------------------------------------------------------------------- # # Scoring logic (simple weighted sum) # ------------------------------------------------------------------- # bullish = 0 bearish = 0 # MACD if macd_sig == 1: bullish += 2 elif macd_sig == -1: bearish += 2 # RSI – over‑bought / over‑sold thresholds if rsi < 70: bullish += 1 if rsi > 30: bearish += 1 # Trend strength (use signed value for direction) if trend > 0 and abs(trend) > 0.3: bullish += 2 if trend < 0 and abs(trend) > 0.3: bearish += 2 # ------------------------------------------------------------------- # # Decide final action # ------------------------------------------------------------------- # if bullish >= 3 and bearish < 3: signals["action"] = "LONG" signals["confidence"] = min(1.0, bullish / 5.0) elif bearish >= 3 and bullish < 3: signals["action"] = "SHORT" signals["confidence"] = min(1.0, bearish / 5.0) else: signals["action"] = "HOLD" signals["confidence"] = 0.5 return signals # --------------------------------------------------------------------------- # # Account / order helpers # --------------------------------------------------------------------------- # def set_leverage() -> bool: """Apply the configured leverage to the futures account.""" payload = { "symbol": config.symbol, "marginMode": config.margin_mode, "leverage": str(config.leverage_multiplier), } result = make_api_request("POST", "/api/mix/v1/account/setLeverage", payload) success = "error" not in result if not success: log.error("Leverage set failed: %s", result.get("message")) return success def get_account_balance() -> float: """Return the available USDT balance for the futures account.""" result = make_api_request("GET", "/api/mix/v1/account/accounts") if "error" in result or "data" not in result: log.error("Balance fetch failed: %s", result.get("message")) return 0.0 for acct in result["data"]: if acct.get("marginCoin") == "USDT": try: return float(acct.get("available", 0)) except (TypeError, ValueError): return 0.0 return 0.0 def _place_order(side: str, quantity: float) -> bool: """Internal helper – builds the order payload and sends it.""" payload = { "symbol": config.symbol, "marginCoin": "USDT", "side": side, "orderType": "market", "size": str(quantity), "timeInForce": "normal", # <-- fixed typo } result = make_api_request("POST", "/api/mix/v1/order/placeOrder", payload) ok = "error" not in result if not ok: log.error("Order %s failed: %s", side, result.get("message")) return ok def open_long_position(quantity: float) -> bool: return _place_order("open_long", quantity) def open_short_position(quantity: float) -> bool: return _place_order("open_short", quantity) def close_position() -> bool: """Close whichever side is currently open (if any).""" with trading_state.lock: if trading_state.current_position == "long": side = "close_long" elif trading_state.current_position == "short": side = "close_short" else: # No open position – nothing to do return True qty = trading_state.position_size payload = { "symbol": config.symbol, "marginCoin": "USDT", "side": side, "orderType": "market", "size": str(qty), "timeInForce": "normal", } result = make_api_request("POST", "/api/mix/v1/order/placeOrder", payload) if "error" in result: log.error("Close position failed: %s", result.get("message")) return False # Update realised P&L cur_price = get_current_price() with trading_state.lock: if cur_price and trading_state.entry_price: if trading_state.current_position == "long": pnl = (cur_price - trading_state.entry_price) * trading_state.position_size else: pnl = (trading_state.entry_price - cur_price) * trading_state.position_size trading_state.realized_pnl += pnl if pnl > 0: trading_state.winning_trades += 1 # Reset position state trading_state.current_position = None trading_state.position_size = 0.0 trading_state.entry_price = 0.0 return True # --------------------------------------------------------------------------- # # Risk checks # --------------------------------------------------------------------------- # def check_position_health() -> bool: """Enforce stop‑loss / take‑profit. Returns ``True`` if